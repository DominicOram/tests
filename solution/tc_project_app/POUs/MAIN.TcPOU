<?xml version="1.0" encoding="utf-8"?>
<TcPlcObject Version="1.1.0.1" ProductVersion="3.1.4024.0">
  <POU Name="MAIN" Id="{33eb6f49-7781-4211-a70b-87ada6d80cb7}" SpecialFunc="None">
    <Declaration><![CDATA[PROGRAM MAIN
VAR
    sVersion: STRING:='1.0.0';
    i : UINT; //index variable for AXES()
    aFbAxes: ARRAY [1..gvl_app.axisNum] OF FB_Axis;
    hmiAxisSelection    :   INT:=1;     //Not possible to use local hmi variables for array indexes

(******Outputs: Power for Limit switches and Home Sensors (every 4th output)********)

    bOutput1 AT %Q*: BOOL:= TRUE;
    bOutput2 AT %Q*: BOOL:= TRUE;
    bOutput3 AT %Q*: BOOL:= TRUE;
    //bOutput4 AT %Q*: BOOL:= TRUE;
    bOutput5 AT %Q*: BOOL:= TRUE;
    bOutput6 AT %Q*: BOOL:= TRUE;
    bOutput7 AT %Q*: BOOL:= TRUE;
    //bOutput8 AT %Q*: BOOL:= TRUE;
    //bOutput9 AT %Q*: BOOL:= TRUE;
    //bOutput13 AT %Q*: BOOL:= TRUE;
    //bOutput17 AT %Q*: BOOL:= TRUE;
    //bOutput21 AT %Q*: BOOL:= TRUE;
    //bOutput24 AT %Q*: BOOL:= TRUE;
    //bOutput28 AT %Q*: BOOL:= TRUE;

(******Error Handling********)
    fbErrorSystem: FB_ErrorSystem;
    aFbAxesError: ARRAY [1..gvl_app.axisNum] OF FB_NC_Error;

    //fbEL1018  : EL1018;
    //fbEL2808  : EL2808;
    //fbEL5101  : EL5101;
    //fbEL9505  : EL9505;
    //fbEL1252  : EL1252;
    //fbEL9410  : EL9410;
    //fbEL7037  : EL7037;
    //fbEK1110  : EK1110;

(******Startup, Shutdown and UPS********)
    eStartUp: (ColdStart, ReadAxisFeedbackType, CheckReadDone, PrepareToRestore, ExecuteRestore, CheckRestore, FinishRestore);
    bPositionRestoreDone   : BOOL := FALSE;
    bExecuteReadEncRefSys  : BOOL := TRUE;
    iRetry                 : INT;
    fbReadEncRefSys        : ARRAY [1..gvl_app.axisNum] OF MC_ReadParameter;
    fbUPS                  : FB_S_UPS_CX51x0;
    eUpsMode               : E_S_UPS_Mode   := eSUPS_WrPersistData_Shutdown;
    fbRestorePosition      : ARRAY [1..GVL_app.axisNum] OF MC_SetPosition;

END_VAR
VAR PERSISTENT
    iPositionAtShutdown       : ARRAY [1..gvl_app.axisNum] OF LREAL;
    bMovingAtShutdown      : ARRAY [1..gvl_app.axisNum] OF BOOL;
END_VAR]]></Declaration>
    <Implementation>
      <ST><![CDATA[fbUPS(eUpsMode := eUpsMode); (* call UPS-FB instance in first lines of the fastest PLC Task *)

IF eGlobalSUpsState = eSUPS_PowerFailure THEN
    (* first cycle of powerfailure *)
    (* execute code that should only be done once with each powerfailure, i.e. increase powerfailure counter *)
    SHUTDOWN();
ELSIF eGlobalSUpsState > eSUPS_PowerFailure THEN
    (* next cycles of powerfailure *)
    (* skip regular code execution for the remaining cycles of the powerfailure/writing of persistent data/quick shutdown  ... *)
    RETURN;
END_IF

STARTUP();
PROG();
AXES();
ERROR();]]></ST>
    </Implementation>
    <Action Name="AXES" Id="{7eb32732-9b53-4934-8cd9-20ba971dd8ff}">
      <Implementation>
        <ST><![CDATA[gvl.axes[1].config.eRestorePosition:=RestorePosition.RestoreWithoutHome;
gvl.axes[2].config.eRestorePosition:=RestorePosition.RestoreWithHome;

FOR GVL.iAxis:=1 TO gvl_app.axisNum DO
    aFbAxes[GVL.iAxis](stAxisStruct:=gvl.axes[GVL.iAxis]);
END_FOR


]]></ST>
      </Implementation>
    </Action>
    <Action Name="ERROR" Id="{35f2cf38-f81e-4aa3-9534-be5fb417817d}">
      <Implementation>
        <ST><![CDATA[//
(****FB containting the log of the errors****)
//
fbErrorSystem(
    En:= TRUE,
    bReset:= ,
    nErrorNum:= ,
    bACK:= ,
    bValidSelection:= ,
    nTableRowIndex:= ,
    EnO=> ,
    nSelectedError=> ,
    pErrorSystem=> );


FOR GVL.iAxis:=1 TO gvl_app.axisNum DO
    aFbAxesError[gvl.iAxis](EN:=TRUE,
    nNC_ErrorID:= gvl.axes[gvl.iAxis].status.nErrorID,
    nNC_AxisID:=gvl.axes[gvl.iAxis].Axis.NcToPlc.AxisId,
    ErrorSystem:= fbErrorSystem.pErrorSystem);
END_FOR



(*call all the necessary instance (input assistance F2 or right click) according to the terminals that you have in your hardware and
 add "TRUE" in the input En, the corresponding number of termianl to the iTerminal_ID and
the variable "fbErrorSystem.pErrorSystem" to the input ErrorSystem in each FB E. g. :
fbEL1808(
    En:= TRUE,
    iTerminal_ID:= 01,
    ErrorSystem:= fbErorSystem.pErrorSystem,
    EnO=> ,
    bError=> );
 *)

]]></ST>
      </Implementation>
    </Action>
    <Action Name="PROG" Id="{5d03ebbb-2a47-4890-ad6d-e82daf72dc51}">
      <Implementation>
        <ST><![CDATA[//
(* Program any sequence, safety or feature (if necessary) application specific in thsi section*)

//]]></ST>
      </Implementation>
    </Action>
    <Action Name="SHUTDOWN" Id="{cb5c9254-2e5f-47b1-9baa-10e728a961b0}">
      <Implementation>
        <ST><![CDATA[FOR i:=1 TO gvl_app.axisNum DO
    iPositionAtShutdown[i]:=gvl.axes[i].Axis.NcToPlc.ActPos;
    bMovingAtShutdown[i]:=gvl.axes[i].Axis.Status.Moving;
END_FOR]]></ST>
      </Implementation>
    </Action>
    <Action Name="STARTUP" Id="{0c7ee537-7bd9-4833-b428-c17cbb57e893}">
      <Implementation>
        <ST><![CDATA[///#########################################################
// This module will restore the position of an incremental axis on startup with the act position it read before losing power.
// It checks the type of axis, 0=incremental, and that the axis was stationary at shut down.
// By default an axis will not restore the position unless it is set to opt-in, i.e. gvl.axes[i].config.eRestorePosition is non-zero.
// There are two modes for position restore:
// 1 'RestoreWithoutHome' -restores the position using a set position fb and does not set the home bit in the axis struct.
// 2 'RestoreWithHome' -restores the position using a normal direct home routine and should set the home bit to TRUE in the axis struct.
// Note: 0 'DontRestore'
// Note from Beckhoff: "A maximum of 1 MB persistent data can be reliably saved over the entire service life."
///#########################################################

// Upon startup bPositionRestoreDone will be set to FALSE, after successfully completing the following code it will be set TRUE
// and should stay TRUE for the rest of the time the PLC is operational, thus this routine should only be completed once.
IF bPositionRestoreDone = FALSE THEN

    // Cycle through function blocks that read the encoder reference system i.e. whether axis is incremental or absolute
    // Result stored in Value, 0=Inc 1=Abs, execute set during the case statement
    FOR i:=1 TO gvl_app.axisNum DO
        fbReadEncRefSys[i](
          Axis:= gvl.axes[i].Axis,
          Enable:= bExecuteReadEncRefSys,
          ParameterNumber:= MC_AxisParameter.AxisEncoderReferenceSystem,
          Value=>,
          ReadMode:= E_READMODE.READMODE_ONCE);
    END_FOR

    // Cycle through set position function blocks for each axis
    // Only axes with RestorePosition=RestoreWithoutHome (mode 1) will be utilised
    FOR i:=1 TO gvl_app.axisNum DO
        fbRestorePosition[i](
         Axis:= gvl.axes[i].Axis,
         Execute:= ,
         Position:= iPositionAtShutdown[i]);
    END_FOR

    CASE eStartUp OF
        ColdStart:
        // First cycle of the PLC, do nothing just give one cycle for variables to initialise
            IF NOT bPositionRestoreDone THEN
                eStartUp:=eStartUp+1;
                iRetry:=0;
            END_IF

        ReadAxisFeedbackType:
        // Exectute the FUNCTION blocks TO read the encoder REFERENCE system (inc OR ABS)
            bExecuteReadEncRefSys:=TRUE;
            eStartUp:=eStartUp+1;

        CheckReadDone:
        // Check the encoder reference system has been read for all axis -> if busy then continue with PLC cycle and check again next time
        // If fbReadEncRefSys not started then go back a step
            FOR i:=1 TO gvl_app.axisNum DO
                IF fbReadEncRefSys[i].Valid = FALSE THEN
                    IF fbReadEncRefSys[i].Busy = TRUE THEN
                        // Exit MAIN.STARTUP Action and wait till next cycle, needs to cycle through whole program in order for data to update
                        RETURN;
                    ELSE
                        // Sometimes the code gets here and the fbReadEncRefSys[i] misses the rising edge.
                        // If  the code gets here it means .valid=FALSE and .busy=FALSE which indicateds the FB probably hasn't started
                        // and thus needs to see a rising edge. Set execute to low and go back a step in the CASE.
                        bExecuteReadEncRefSys:=FALSE;
                        eStartUp:=eStartUp-1;
                        iRetry:=iRetry+1; // counter used for troubleshooting to see how many cycles it takes before fbReadEncRefSys function blocks are read correctly
                        RETURN;
                    END_IF
                END_IF
            END_FOR
            // If the code gets here all axes either have .valid=TRUE for all axes
            eStartUp:=eStartUp+1;

        PrepareToRestore:
        // Prepare to home for axes that opt in for mode 2 RestoreWithHome i.e. normal direct home
            FOR i:=1 TO gvl_app.axisNum DO
                IF fbReadEncRefSys[i].Value=0 AND NOT(bMovingAtShutdown[i]) AND gvl.axes[i].config.eRestorePosition=2 THEN
                    gvl.axes[i].control.eCommand:=MotionFunctions.Home;
                    gvl.axes[i].config.nHomeSeq:=15;
                    gvl.axes[i].config.fHomePosition:=iPositionAtShutdown[i];
                END_IF
            END_FOR
            eStartUp:=eStartUp+1;

        ExecuteRestore:
        // Execute position restore using either mode 1: fbRestorePosition or mode 2: normal direct homing (depending on mode)
            FOR i:=1 TO gvl_app.axisNum DO
                IF fbReadEncRefSys[i].Valid = TRUE AND fbReadEncRefSys[i].Value = 0 THEN
                    CASE GVL.axes[i].config.eRestorePosition OF
                      RestorePosition.RestoreWithoutHome: fbRestorePosition[i].Execute:=TRUE;
                      RestorePosition.RestoreWithHome: gvl.axes[i].control.bExecute:=TRUE;
                    END_CASE
                END_IF
            END_FOR
            eStartUp:=eStartUp+1;

        CheckRestore:
        // Check mode 1: fbRestorePosition or mode 2: direct homing is finished on axes that were opt-in
        // Nothing actually happens if the restore is not done, the code just returns from here each cycle and the
        // bPositionRestoreDone will never get set to TRUE
            FOR i:=1 TO gvl_app.axisNum DO
                IF fbReadEncRefSys[i].Valid = TRUE AND fbReadEncRefSys[i].Value = 0 THEN
                    CASE gvl.axes[i].config.eRestorePosition OF
                      RestorePosition.RestoreWithoutHome:
                        IF NOT fbRestorePosition[i].Done THEN
                            RETURN;
                        END_IF
                      RestorePosition.RestoreWithHome:
                        IF NOT gvl.axes[i].status.bHomed THEN
                            RETURN;
                        END_IF
                    END_CASE
                END_IF
            END_FOR
            eStartUp:=eStartUp+1;

        FinishRestore: // Remove execute = TRUE for fbRestorePosition
            FOR i:=1 TO gvl_app.axisNum DO
                fbRestorePosition[i].Execute:=FALSE;
            END_FOR
            bPositionRestoreDone:=TRUE;
    END_CASE
END_IF]]></ST>
      </Implementation>
    </Action>
    <LineIds Name="MAIN">
      <LineId Id="124" Count="9" />
      <LineId Id="2" Count="0" />
      <LineId Id="189" Count="0" />
      <LineId Id="135" Count="0" />
      <LineId Id="134" Count="0" />
      <LineId Id="81" Count="1" />
    </LineIds>
    <LineIds Name="MAIN.AXES">
      <LineId Id="19" Count="1" />
      <LineId Id="3" Count="0" />
      <LineId Id="1" Count="0" />
      <LineId Id="4" Count="0" />
      <LineId Id="10" Count="0" />
      <LineId Id="7" Count="0" />
      <LineId Id="16" Count="0" />
      <LineId Id="11" Count="0" />
    </LineIds>
    <LineIds Name="MAIN.ERROR">
      <LineId Id="31" Count="0" />
      <LineId Id="10" Count="1" />
      <LineId Id="34" Count="8" />
      <LineId Id="1" Count="0" />
      <LineId Id="90" Count="1" />
      <LineId Id="88" Count="1" />
      <LineId Id="92" Count="2" />
      <LineId Id="87" Count="0" />
      <LineId Id="79" Count="1" />
      <LineId Id="12" Count="0" />
      <LineId Id="44" Count="8" />
      <LineId Id="62" Count="0" />
      <LineId Id="14" Count="0" />
      <LineId Id="33" Count="0" />
    </LineIds>
    <LineIds Name="MAIN.PROG">
      <LineId Id="2" Count="0" />
      <LineId Id="1" Count="0" />
      <LineId Id="5" Count="0" />
      <LineId Id="3" Count="0" />
    </LineIds>
    <LineIds Name="MAIN.SHUTDOWN">
      <LineId Id="2" Count="2" />
      <LineId Id="1" Count="0" />
    </LineIds>
    <LineIds Name="MAIN.STARTUP">
      <LineId Id="99" Count="0" />
      <LineId Id="94" Count="0" />
      <LineId Id="98" Count="0" />
      <LineId Id="101" Count="1" />
      <LineId Id="104" Count="0" />
      <LineId Id="103" Count="0" />
      <LineId Id="105" Count="0" />
      <LineId Id="109" Count="0" />
      <LineId Id="95" Count="0" />
      <LineId Id="206" Count="0" />
      <LineId Id="208" Count="1" />
      <LineId Id="207" Count="0" />
      <LineId Id="100" Count="0" />
      <LineId Id="91" Count="1" />
      <LineId Id="2" Count="7" />
      <LineId Id="96" Count="0" />
      <LineId Id="10" Count="0" />
      <LineId Id="97" Count="0" />
      <LineId Id="11" Count="5" />
      <LineId Id="18" Count="2" />
      <LineId Id="177" Count="0" />
      <LineId Id="21" Count="3" />
      <LineId Id="171" Count="0" />
      <LineId Id="25" Count="0" />
      <LineId Id="178" Count="0" />
      <LineId Id="26" Count="1" />
      <LineId Id="170" Count="0" />
      <LineId Id="29" Count="0" />
      <LineId Id="179" Count="0" />
      <LineId Id="163" Count="0" />
      <LineId Id="152" Count="0" />
      <LineId Id="139" Count="0" />
      <LineId Id="131" Count="0" />
      <LineId Id="155" Count="0" />
      <LineId Id="190" Count="0" />
      <LineId Id="140" Count="0" />
      <LineId Id="157" Count="2" />
      <LineId Id="187" Count="0" />
      <LineId Id="150" Count="1" />
      <LineId Id="200" Count="0" />
      <LineId Id="145" Count="0" />
      <LineId Id="141" Count="0" />
      <LineId Id="166" Count="0" />
      <LineId Id="203" Count="0" />
      <LineId Id="201" Count="0" />
      <LineId Id="169" Count="0" />
      <LineId Id="44" Count="0" />
      <LineId Id="180" Count="0" />
      <LineId Id="45" Count="1" />
      <LineId Id="49" Count="0" />
      <LineId Id="154" Count="0" />
      <LineId Id="153" Count="0" />
      <LineId Id="53" Count="2" />
      <LineId Id="173" Count="0" />
      <LineId Id="56" Count="0" />
      <LineId Id="181" Count="0" />
      <LineId Id="57" Count="8" />
      <LineId Id="174" Count="0" />
      <LineId Id="66" Count="0" />
      <LineId Id="182" Count="0" />
      <LineId Id="204" Count="1" />
      <LineId Id="67" Count="14" />
      <LineId Id="175" Count="0" />
      <LineId Id="82" Count="5" />
      <LineId Id="1" Count="0" />
    </LineIds>
  </POU>
</TcPlcObject>